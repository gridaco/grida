
---------------------------------------------------------------------
-- [Project] --
---------------------------------------------------------------------
create table public.project (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  organization_id bigint not null,
  name text not null,
  ref_id text null,
  constraint project_pkey primary key (id),
  constraint project_ref_id_key unique (ref_id),
  constraint unique_name_per_org unique (organization_id, name),
  constraint unique_org_project unique (organization_id, name),
  constraint public_project_organization_id_fkey foreign KEY (organization_id) references organization (id) on delete CASCADE,
  constraint project_name_check check (
    (
      name ~ '^[a-z\d](?:[a-z\d]|-(?=[a-z\d])){1,38}$'::text
    )
  )
) TABLESPACE pg_default;

create index IF not exists project_organization_id_idx on public.project using btree (organization_id) TABLESPACE pg_default;


ALTER TABLE public.project ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow insert based on membership" ON "public"."project" FOR INSERT WITH CHECK ("public"."rls_organization"("organization_id"));
CREATE POLICY "select_project" ON "public"."project" FOR SELECT USING ("public"."rls_project"("id"));


---------------------------------------------------------------------
-- [trigger set_project_ref_id] --
---------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.set_project_ref_id()
RETURNS TRIGGER AS $$
BEGIN
    -- Check if ref_id is not already set
    IF NEW.ref_id IS NULL THEN
        -- Generate the ref_id using id_encode on the ID of the newly inserted row
        NEW.ref_id := id_encode(NEW.id);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

create trigger trigger_set_ref_id BEFORE INSERT on public.project for EACH row execute FUNCTION public.set_project_ref_id();


---------------------------------------------------------------------
-- [trigger insert_www_for_new_project] --
---------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.insert_www_for_new_project()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO grida_www.www (project_id, title)
  VALUES (NEW.id, NEW.name);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- [trigger] insert_www_for_new_project
CREATE TRIGGER trg_insert_site_for_project AFTER INSERT ON public.project FOR EACH ROW EXECUTE FUNCTION public.insert_www_for_new_project();



---------------------------------------------------------------------
-- [rls_project] --
---------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.rls_project(project_id bigint) RETURNS boolean
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    AS $$BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM organization_member om
        JOIN project p ON om.organization_id = p.organization_id
        WHERE p.id = project_id AND om.user_id = auth.uid()
    );
END;$$;


---------------------------------------------------------------------
-- [project access state] --
---------------------------------------------------------------------
create table public.user_project_access_state (
    user_id uuid primary key references auth.users(id) on delete cascade default auth.uid(),
    project_id bigint null references project(id) on delete set null,
    document_id uuid null references document(id) on delete set null,
    updated_at timestamp with time zone not null default now()
) TABLESPACE pg_default;

ALTER TABLE public.user_project_access_state ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all based on user_id" ON public.user_project_access_state USING ((user_id = auth.uid())) WITH CHECK (user_id = auth.uid());



---------------------------------------------------------------------
-- [RPC] mark_access --
---------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.workspace_mark_access(
  p_organization_name text,
  p_project_name text,
  p_document_id uuid DEFAULT NULL
)
RETURNS void AS $$
DECLARE
  resolved_project_id bigint;
BEGIN
  SELECT p.id INTO resolved_project_id
  FROM public.project p
  JOIN public.organization o ON o.id = p.organization_id
  WHERE o.name = p_organization_name
    AND p.name = p_project_name
    AND public.rls_project(p.id)
  LIMIT 1;

  IF resolved_project_id IS NULL THEN
    RAISE EXCEPTION 'Project not found or access denied for %/%', p_organization_name, p_project_name;
  END IF;

  INSERT INTO public.user_project_access_state (user_id, project_id, document_id, updated_at)
  VALUES (auth.uid(), resolved_project_id, p_document_id, now())
  ON CONFLICT (user_id) DO UPDATE
  SET project_id = EXCLUDED.project_id,
      document_id = EXCLUDED.document_id,
      updated_at = now();
END;
$$ LANGUAGE plpgsql VOLATILE;
