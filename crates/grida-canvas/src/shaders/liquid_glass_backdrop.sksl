/**
 * Liquid Glass Effect Shader - Backdrop Version
 * 
 * A physically-based glass shader featuring:
 * - Real-time refraction with chromatic aberration
 * - Fresnel reflections at grazing angles
 * - SDF-based shape morphing
 * - Supersampled anti-aliasing
 * - Pre-blurred backdrop (via Skia's native blur ImageFilter)
 * 
 * This version uses SaveLayer backdrop input instead of manually captured images.
 * The backdrop is pre-blurred by Skia's ImageFilter chain for optimal performance.
 */

uniform vec4 box;               // Bounding box (x, y, width, height)
uniform vec4 corner_radii;      // Corner radii [top-left, top-right, bottom-right, bottom-left]
uniform mat3 transform;         // Transformation matrix for shape positioning
uniform vec2 resolution;        // Canvas resolution in pixels
uniform shader backdrop;        // Pre-blurred backdrop from SaveLayer (Skia provides this automatically!)

// LiquidGlassEffect parameters
uniform float light_intensity;  // Transmission/transparency [0.0-1.0]
uniform float light_angle;      // Light angle in degrees (reserved)
uniform float refraction;       // Index of refraction [1.0-2.0]
uniform float depth;            // Glass thickness/depth for 3D effect [1.0+]
uniform float dispersion;       // Chromatic aberration strength [0.0-1.0]

/**
 * Signed Distance Function for rounded box
 * Returns distance from point p to the surface (negative = inside)
 */
float sdRoundedBox( in vec2 p, in vec2 b, in vec4 r ) {
  r.xy = (p.x>0.0) ? r.xy : r.zw;
  r.x  = (p.y>0.0) ? r.x  : r.y;
  vec2 q = abs(p)-b+r.x;
  float d = min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;
  return d;
}

/**
 * Transform screen-space point through inverse transformation matrix
 * Converts screen coordinates to shape-local coordinates
 */
vec2 project(vec2 p, mat3 m) {
  vec3 result =  inverse(m) * vec3(p, 1.0);
  return result.xy;
}

/**
 * Main SDF - computes signed distance to glass shape
 * Negative values = inside shape, positive = outside
 */
float sdf(vec2 xy) {
  vec2 p = project(xy, transform);
  // Simple pill shape - only rounded rectangle
  return sdRoundedBox(p - box.xy - box.zw * 0.5, box.zw * 0.5, corner_radii);
}

/**
 * Calculate SDF gradient using finite differences
 * Used to compute surface normals for lighting
 */
vec2 calculateGradient(vec2 p) {
    const float epsilon = 0.001;
    float dx = sdf(p + vec2(epsilon, 0.0)) - sdf(p - vec2(epsilon, 0.0));
    float dy = sdf(p + vec2(0.0, epsilon)) - sdf(p - vec2(0.0, epsilon));
    return vec2(dx, dy) / (2.0 * epsilon);
}

/**
 * Calculate 3D surface normal from 2D SDF gradient
 * Creates a curved 3D surface from the 2D distance field
 * The surface curves up from the edges (like a lens or pad)
 */
vec3 getNormal(float sd, vec2 gradient, float thickness)
{
    float dx = gradient.x;
    float dy = gradient.y;
    // The cosine and sine between normal and the xy plane.
    float n_cos = max(thickness + sd, 0.0) / thickness;
    float n_sin = sqrt(1.0 - n_cos * n_cos);
    return normalize(vec3(dx * n_cos, dy * n_cos, n_sin));
}

/**
 * Calculate height (Z component) of glass surface at given distance
 * Creates a curved surface (highest at center, falling off at edges)
 * Returns value from 0.0 (outside) to thickness (at center)
 */
float height(float sd, float thickness)
{
    if(sd >= 0.0)
    {
        return 0.0;
    }
    if(sd < -thickness)
    {
        return thickness;
    }
    float x = thickness + sd;
    return sqrt(thickness * thickness - x * x);
}

/**
 * Calculate liquid glass material effect
 * Implements physically-based glass with refraction, fresnel, and chromatic aberration
 */
vec4 calculateLiquidGlass(float sd, vec2 g, vec2 fragCoord)
{
    // Use LiquidGlassEffect parameters
    float thickness = depth;
    float transmission = light_intensity;  // Light intensity controls transmission
    float roughness = 0.1;                 // Keep fixed for now
    float ior = refraction;                // Refraction controls index of refraction
    float chromaticAberration = dispersion; // Dispersion controls chromatic aberration
    float distortionScale = 1.0;           // Keep fixed for now
    
    vec3 normal = getNormal(sd, g * distortionScale, thickness);
    
    // View direction (straight down - this is what should refract)
    vec3 view_dir = vec3(0.0, 0.0, -1.0);
    
    // Fresnel effect - more reflection at grazing angles
    float fresnel = pow(1.0 - abs(dot(view_dir, normal)), 3.0);
    
    // Base refraction - based on view direction, not light direction
    vec3 refract_vec = refract(view_dir, normal, 1.0/ior);
    float h = height(sd, thickness);
    float base_height = thickness * 8.0;
    float refract_length = (h + base_height) / dot(vec3(0.0, 0.0, -1.0), refract_vec);
    
    // Chromatic aberration - sample RGB channels separately with dispersion
    vec2 base_coord = fragCoord + refract_vec.xy * refract_length;
    vec2 uv_base = base_coord / resolution.xy;
    
    // Chromatic aberration offset - use original working approach
    // Offset is proportional to refraction vector and dispersion parameter
    vec2 offset = refract_vec.xy * chromaticAberration;
    
    // Sample in UV space (normalized coordinates), then use pre-blurred backdrop
    // Backdrop is already blurred by Skia's ImageFilter for optimal performance
    vec2 coord_r = (uv_base - offset) * resolution;
    vec2 coord_g = uv_base * resolution;
    vec2 coord_b = (uv_base + offset) * resolution;
    
    // Sample pre-blurred backdrop for each channel (chromatic aberration)
    float r = backdrop.eval(coord_r).r;
    float g_channel = backdrop.eval(coord_g).g;
    float b = backdrop.eval(coord_b).b;
    vec4 refract_color = vec4(r, g_channel, b, 1.0);
    
    // Roughness-based reflection blur (simplified)
    vec3 reflect_vec = reflect(view_dir, normal);
    vec4 reflect_color = vec4(0.0);
    
    // Mix reflection and refraction based on fresnel and transmission
    vec4 glass_color = mix(refract_color, reflect_color, fresnel * (1.0 - transmission));
    
    return glass_color;
}

/**
 * Render a single pixel/sample
 * Determines if pixel is inside or outside glass and renders accordingly
 */
vec4 render(vec2 xy) {
  vec2 p = project(xy, transform);
  float d = sdf(xy);
  vec2 g = calculateGradient(p);
  if (d > 0.0) {
    // Outside glass: sample sharp background from backdrop
    return backdrop.eval(xy);
  } else {
    // Inside glass: apply liquid glass effect
    return calculateLiquidGlass(d, g, xy);
  }
}

/**
 * Main shader entry point
 * Implements 4x4 supersampled anti-aliasing for smooth edges
 */
vec4 main(vec2 fragCoord) {
  // Anti-aliasing settings
  const int samples = 4;
  float sampleStrength = 1.0/float(samples*samples);
  vec4 finalColor = vec4(0.0);
  
  // Perform supersampling
  for(int m = 0; m < samples; m++) {
    for(int n = 0; n < samples; n++) {
      // Calculate offset for this sample (only if using AA)
      vec2 offset = (samples > 1) ? 
          (vec2(float(m), float(n)) / float(samples) - 0.5/float(samples)) : 
          vec2(0.0);
      
      // Get pixel position with the offset
      vec2 p = fragCoord + offset;
      
      // Render this sample
      vec4 color = render(p);
      // Accumulate color
      finalColor += color * sampleStrength;
    }
  }
  
  return finalColor;
}

