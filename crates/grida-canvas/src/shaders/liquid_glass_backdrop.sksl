/**
 * Liquid Glass Effect Shader - Backdrop Version
 * 
 * A physically-based glass shader featuring:
 * - Real-time refraction with chromatic aberration
 * - Fresnel reflections at grazing angles
 * - SDF-based shape morphing
 * - Supersampled anti-aliasing
 * - Pre-blurred backdrop (via Skia's native blur ImageFilter)
 * 
 * This version uses SaveLayer backdrop input instead of manually captured images.
 * The backdrop is pre-blurred by Skia's ImageFilter chain for optimal performance.
 */

uniform vec4 box;               // Bounding box (x, y, width, height)
uniform vec4 corner_radii;      // Corner radii [top-left, top-right, bottom-right, bottom-left]
uniform mat3 transform;         // Transformation matrix for shape positioning
uniform vec2 resolution;        // Canvas resolution in pixels
uniform shader backdrop;        // Pre-blurred backdrop from SaveLayer (Skia provides this automatically!)

// LiquidGlassEffect parameters
uniform float light_intensity;  // Transmission/transparency [0.0-1.0]
uniform float light_angle;      // Light angle in degrees (reserved)
uniform float refraction;       // Refraction strength [0.0-1.0], maps to IOR [1.0-2.0]
uniform float depth;            // Glass thickness/depth in absolute pixels [1.0+]
uniform float dispersion;       // Chromatic aberration strength [0.0-1.0]

/**
 * Signed Distance Function for rounded box
 * Returns distance from point p to the surface (negative = inside)
 */
float sdRoundedBox( in vec2 p, in vec2 b, in vec4 r ) {
  r.xy = (p.x>0.0) ? r.xy : r.zw;
  r.x  = (p.y>0.0) ? r.x  : r.y;
  vec2 q = abs(p)-b+r.x;
  float d = min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;
  return d;
}

/**
 * Transform screen-space point through inverse transformation matrix
 * Converts screen coordinates to shape-local coordinates
 */
vec2 project(vec2 p, mat3 m) {
  vec3 result =  inverse(m) * vec3(p, 1.0);
  return result.xy;
}

/**
 * Main SDF - computes signed distance to glass shape
 * Negative values = inside shape, positive = outside
 */
float sdf(vec2 xy) {
  vec2 p = project(xy, transform);
  // Simple pill shape - only rounded rectangle
  return sdRoundedBox(p - box.xy - box.zw * 0.5, box.zw * 0.5, corner_radii);
}

/**
 * Calculate SDF gradient using finite differences
 * Used to compute surface normals for lighting
 */
vec2 calculateGradient(vec2 p) {
    const float epsilon = 0.001;
    float dx = sdf(p + vec2(epsilon, 0.0)) - sdf(p - vec2(epsilon, 0.0));
    float dy = sdf(p + vec2(0.0, epsilon)) - sdf(p - vec2(0.0, epsilon));
    return vec2(dx, dy) / (2.0 * epsilon);
}

/**
 * Calculate 3D surface normal from 2D SDF gradient
 * Creates a curved 3D surface from the 2D distance field
 * The surface curves up from the edges (like a lens or pad)
 */
vec3 getNormal(float sd, vec2 gradient, float thickness)
{
    float dx = gradient.x;
    float dy = gradient.y;
    // The cosine and sine between normal and the xy plane.
    float n_cos = max(thickness + sd, 0.0) / thickness;
    float n_sin = sqrt(1.0 - n_cos * n_cos);
    return normalize(vec3(dx * n_cos, dy * n_cos, n_sin));
}

/**
 * Calculate height (Z component) of glass surface at given distance
 * Creates a curved surface (highest at center, falling off at edges)
 * Returns value from 0.0 (outside) to thickness (at center)
 */
float height(float sd, float thickness)
{
    if(sd >= 0.0)
    {
        return 0.0;
    }
    if(sd < -thickness)
    {
        return thickness;
    }
    float x = thickness + sd;
    return sqrt(thickness * thickness - x * x);
}

/**
 * Calculate liquid glass material effect
 * Top-view orthographic refraction - backdrop displacement based on surface angle
 */
vec4 calculateLiquidGlass(float sd, vec2 g, vec2 fragCoord)
{
    // Use LiquidGlassEffect parameters
    // Depth is in absolute pixels, minimum 1.0
    float thickness = max(depth, 1.0);
    float transmission = light_intensity;  // Light intensity controls transmission
    
    // Convert normalized refraction [0.0-1.0] to IOR [1.0-2.0]
    // 0.0 = no refraction (IOR 1.0, air), 1.0 = strong refraction (IOR 2.0)
    float ior = 1.0 + refraction;
    
    float dispersionAmount = dispersion;   // Dispersion controls chromatic aberration
    float distortionScale = 1.0;           // Keep fixed for now
    
    // Get surface normal at this point
    vec3 normal = getNormal(sd, g * distortionScale, thickness);
    
    // View direction (straight down - orthographic projection)
    vec3 view_dir = vec3(0.0, 0.0, -1.0);
    
    // Calculate base reflectance (F0) using Schlick's approximation
    float F0 = pow((1.0 - ior) / (1.0 + ior), 2.0);
    
    // Fresnel effect - physically accurate (Schlick's approximation)
    float cosTheta = max(dot(-view_dir, normal), 0.0);
    float fresnel = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
    
    // Top-view refraction: Calculate displacement based on surface angle
    // When viewing from top, we see the backdrop displaced by the surface normal's tilt
    // The XY components of the refracted ray determine the displacement
    
    // Wavelength-dependent IOR for chromatic aberration (Cauchy's equation approximation)
    // At dispersion=1.0, creates very strong, dramatic rainbow effect at edges
    float ior_r = ior - dispersionAmount * 0.15;  // Red bends less
    float ior_g = ior;                            // Green (reference)
    float ior_b = ior + dispersionAmount * 0.15;  // Blue bends more
    
    // Calculate refraction displacement for each color channel
    vec3 refract_color = vec3(0.0);
    vec3 iors = vec3(ior_r, ior_g, ior_b);
    
    for(int i = 0; i < 3; i++) {
        float channel_ior = iors[i];
        
        // Calculate refraction vector for this wavelength
        vec3 refract_vec = refract(view_dir, normal, 1.0 / channel_ior);
        
        // Check for total internal reflection
        if(length(refract_vec) < 0.01) {
            // TIR - use white reflection
            refract_color[i] = 1.0;
            continue;
        }
        
        // Calculate displacement based on surface angle and glass thickness
        // The displacement is proportional to:
        // 1. How much the surface is tilted (refract_vec.xy)
        // 2. The thickness of the glass (creates more displacement)
        // 3. The IOR (higher IOR = more bending)
        
        // For top-view, displacement should be visible
        // Scale factor controls the strength of the refraction effect
        float displacement_scale = thickness * 0.5;
        
        // Calculate the offset based on refracted ray's XY components
        vec2 offset = refract_vec.xy * displacement_scale;
        
        // Sample backdrop with offset
        vec2 sample_pos = fragCoord + offset;
        refract_color[i] = backdrop.eval(sample_pos)[i];
    }
    
    vec4 refracted = vec4(refract_color, 1.0);
    
    // Reflection - create bright highlights at grazing angles
    // Use white reflection for rim lighting effect
    vec4 reflected = vec4(1.0, 1.0, 1.0, 1.0);
    
    // Mix reflection and refraction based on Fresnel and transmission
    // Fresnel determines reflection amount, transmission parameter scales it
    float reflection_amount = fresnel * (1.0 - transmission);
    vec4 glass_color = mix(refracted, reflected, reflection_amount);
    
    return glass_color;
}

/**
 * Render a single pixel/sample
 * Determines if pixel is inside or outside glass and renders accordingly
 */
vec4 render(vec2 xy) {
  vec2 p = project(xy, transform);
  float d = sdf(xy);
  vec2 g = calculateGradient(p);
  if (d > 0.0) {
    // Outside glass: sample sharp background from backdrop
    return backdrop.eval(xy);
  } else {
    // Inside glass: apply liquid glass effect
    return calculateLiquidGlass(d, g, xy);
  }
}

/**
 * Main shader entry point
 * Implements 4x4 supersampled anti-aliasing for smooth edges
 */
vec4 main(vec2 fragCoord) {
  // Anti-aliasing settings
  const int samples = 4;
  float sampleStrength = 1.0/float(samples*samples);
  vec4 finalColor = vec4(0.0);
  
  // Perform supersampling
  for(int m = 0; m < samples; m++) {
    for(int n = 0; n < samples; n++) {
      // Calculate offset for this sample (only if using AA)
      vec2 offset = (samples > 1) ? 
          (vec2(float(m), float(n)) / float(samples) - 0.5/float(samples)) : 
          vec2(0.0);
      
      // Get pixel position with the offset
      vec2 p = fragCoord + offset;
      
      // Render this sample
      vec4 color = render(p);
      // Accumulate color
      finalColor += color * sampleStrength;
    }
  }
  
  return finalColor;
}

