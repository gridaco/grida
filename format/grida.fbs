// =============================================================================
// Grida — Universal Document Schema (FlatBuffers) (DRAFT)
// =============================================================================
//
// Goal:
// - A single, universal, evolvable, binary document format for large documents.
// - Aligned to:
//   - Rust runtime model: `crates/grida-canvas/src/node/schema.rs`
//   - TS document model: `packages/grida-canvas-schema/grida.ts`
//
// Key decisions (draft):
// - Node IDs are stored as packed u32 (actor:8 | counter:24), matching the DB draft.
//   - TS `grida.id.u32` can pack/unpack/format to/from string.
// - Document is a flat node map + explicit ordered link list (no nested children arrays).
// - Node payload is modeled via a FlatBuffers union for forward evolution.
//
// -----------------------------------------------------------------------------
// CAUTION — FlatBuffers semantics & schema design rules (READ BEFORE EDITING)
// -----------------------------------------------------------------------------
//
// FlatBuffers has specific semantics that materially affect how this schema
// behaves, evolves, and remains backward-compatible. The following rules are
// *intentional constraints* on how this schema must be extended.
//
// 1) Scalars are always readable — "unset" does NOT exist
//    -----------------------------------------------------
//    - Scalar fields (float, int, enum, bool) in FlatBuffers tables always have
//      a readable value at decode time.
//    - There is NO way to distinguish:
//        "value explicitly set by author"
//        vs
//        "value implicitly returned by FlatBuffers default (usually 0)"
//    - Therefore:
//        * If `0` (or the default enum value) has real semantic meaning,
//          it MUST NOT be used to represent "unset".
//        * Using sentinel values like `0` or `(0,0)` to mean "unset" is fragile
//          and must be avoided unless the value domain makes it impossible for
//          the sentinel to be valid.
//
//    REQUIRED RULE:
//    - If the distinction between "unset" and "set" matters, the value MUST be
//      wrapped in a nullable table or expressed via a union.
//    - Do NOT rely on scalar defaults to encode intent.
//
//
// 2) Prefer tables over structs — structs are permanent and inflexible
//    ------------------------------------------------------------------
//    - FlatBuffers structs:
//        * are always present
//        * cannot be null
//        * cannot have defaults
//        * cannot evolve (no fields can be added later)
//    - Once a struct is introduced, its binary layout is frozen forever.
//
//    REQUIRED RULE:
//    - Use `struct` ONLY for:
//        * pure mathematical data
//        * fixed-size, value-only types
//        * domains where `0` is always a valid value
//        * types that are extremely unlikely to ever gain optional fields,
//          modes, variants, or semantic extensions
//
//    - Use `table` for:
//        * anything optional
//        * anything user-authored
//        * anything with semantic meaning beyond raw math
//        * anything that may plausibly evolve in the future
//
//    When in doubt: USE A TABLE.
//
//
// 3) Schema evolution principle
//    --------------------------
//    This schema is designed for long-term evolution.
//    Any change that:
//      - makes it impossible to distinguish user intent
//      - introduces ambiguous defaults
//      - freezes a value shape prematurely
//    will make future evolution harder or unsafe.
//
//    Prefer explicitness and nullability over compactness.
// -----------------------------------------------------------------------------
// NOTE:
// - This is a first pass draft.
// =============================================================================

namespace grida;

file_extension "grida";
file_identifier "GRID";

// -----------------------------------------------------------------------------
// Core primitives (Rust `crates/grida-canvas/src/cg/**` aligned)
// -----------------------------------------------------------------------------

/// Node identifier (temporary: string-based for compatibility with current editor).
///
/// TODO: Update to use packed u32 (actor:8 | counter:24) for better performance.
/// Range: 0..=4_294_967_295.
///
/// Current implementation uses string IDs to match TS editor model.
/// Future: migrate to struct NodeIdentifier { packed:uint; } for efficiency.
table NodeIdentifier {
  /// Required: unique identifier string for the node.
  id:string (id: 0, required);
}

/// Parent reference with fractional index position for ordering.
///
/// Uses fractional indexing (orderable strings) to enable conflict-free
/// ordering in collaborative systems. The position string is designed to
/// sort correctly when compared lexicographically.
///
/// Examples of fractional index strings: "!", " ~\"", "Qd&", "QeU", "Qe7", "QeO"
///
/// Reference: Figma uses this same pattern (see `ParentIndex` in fig.kiwi).
/// This enables:
/// - Flat node structure (no nested children arrays)
/// - Efficient node moves (single node update, no parent reordering)
/// - Concurrent editing friendly ordering
///
/// Note: Table (not struct) because it contains NodeIdentifier (a table).
/// This field is optional (can be null for root nodes).
table ParentReference {
  /// Parent node identifier
  parent_id:NodeIdentifier (required, id: 0);
  /// Fractional index position string for ordering among siblings.
  /// Empty string means "unsorted" or "default position".
  /// Children are sorted by lexicographic comparison of position strings.
  position:string (id: 1);
}

/// Rust: `CGPoint { x: f32, y: f32 }`
struct CGPoint {
  x:float;
  y:float;
}

/// Rust: `Alignment(pub f32, pub f32)` (cNDC, range typically [-1, 1])
struct Alignment {
  x:float;
  y:float;
}

/// Rust: `Uv(pub f32, pub f32)` (normalized [0, 1] domain)
struct UV {
  u:float;
  v:float;
}

/// Rust: (no dedicated cg struct) used throughout as (w,h). Keep for schema convenience.
struct CGSize {
  width:float;
  height:float;
}

/// RGBA in linear float space (0..1).
struct RGBA32F {
  r:float;
  g:float;
  b:float;
  a:float;
}

/// Rust: `CGTransform2D { m00..m12: f32 }` (and compatible with math2 `AffineTransform`).
///
/// Matrix layout:
/// [ m00  m01  m02 ]
/// [ m10  m11  m12 ]
/// [  0    0    1  ]
///
/// Struct representation (no defaults in FlatBuffers structs).
struct CGTransform2D {
  m00:float;
  m01:float;
  m02:float;
  m10:float;
  m11:float;
  m12:float;
}

/// Rust: `Radius { rx: f32, ry: f32 }`
struct CGRadius {
  rx:float;
  ry:float;
}

struct EdgeInsets {
  top:float;
  right:float;
  bottom:float;
  left:float;
}

/// Rust: `RectangularCornerRadius { tl,tr,bl,br: Radius }`
struct RectangularCornerRadius {
  tl:CGRadius;
  tr:CGRadius;
  bl:CGRadius;
  br:CGRadius;
}

/// Per-side stroke widths (archive model).
///
/// Struct representation. Note: structs cannot be null/omitted; all-zeros can be
/// interpreted as "not used" by codec/runtime if desired.
struct RectangularStrokeWidth {
  stroke_top_width:float;
  stroke_right_width:float;
  stroke_bottom_width:float;
  stroke_left_width:float;
}

// -----------------------------------------------------------------------------
// Enums (string mapping handled by codec layers)
// -----------------------------------------------------------------------------

/// node type
enum NodeType : byte {
  Exception,
  Scene,

  // groups and containers
  Group,
  InitialContainer,
  Container,
  BooleanOperation,

  // shapes
  Rectangle,
  Ellipse,
  Polygon,
  RegularPolygon,
  RegularStarPolygon,
  Path,
  Line,
  Vector,

  // text
  TextSpan,
}

// TODO: remove this
/// shape node type (flag within BasicShapeNode)
enum BasicShapeNodeType : byte {
  Rectangle = 0,
  Ellipse = 1,
  Polygon = 2,
  RegularPolygon = 3,
  RegularStarPolygon = 4,
  Path = 5,
}

/// Rust: `BlendMode` (does not include pass-through)
enum BlendMode : byte {
  Normal = 0,
  Multiply = 1,
  Screen = 2,
  Overlay = 3,
  Darken = 4,
  Lighten = 5,
  ColorDodge = 6,
  ColorBurn = 7,
  HardLight = 8,
  SoftLight = 9,
  Difference = 10,
  Exclusion = 11,
  Hue = 12,
  Saturation = 13,
  Color = 14,
  Luminosity = 15
}

/// Archive model: flattened blend mode with pass-through included.
///
/// This duplicates `BlendMode` variants and adds `pass_through`, avoiding a union/table wrapper.
enum LayerBlendMode : byte {
  Normal = 0,
  Multiply = 1,
  Screen = 2,
  Overlay = 3,
  Darken = 4,
  Lighten = 5,
  ColorDodge = 6,
  ColorBurn = 7,
  HardLight = 8,
  SoftLight = 9,
  Difference = 10,
  Exclusion = 11,
  Hue = 12,
  Saturation = 13,
  Color = 14,
  Luminosity = 15,

  /// Archive-only sentinel: corresponds to Rust `LayerBlendMode::PassThrough`.
  /// Set to 100 to avoid confusing it with `BlendMode` ids.
  PassThrough = 100
}

/// Rust: `Axis`
enum Axis : byte {
  Horizontal = 0,
  Vertical = 1
}

/// Rust: `TileMode`
enum TileMode : byte {
  Clamp = 0,
  Repeated = 1,
  Mirror = 2,
  Decal = 3
}

/// Rust: `math2::box_fit::BoxFit`
enum BoxFit : byte {
  Contain = 0,
  Cover = 1,
  Fill = 2,
  None = 3
}

/// Rust: `ImageRepeat`
enum ImageRepeat : byte {
  RepeatX = 0,
  RepeatY = 1,
  Repeat = 2
}

enum LayoutMode : byte {
  Normal = 0,
  Flex = 1
}

enum LayoutWrap : byte {
  None = 0,
  Wrap = 1,
  NoWrap = 2
}

enum LayoutPositionBasis : byte {
  Cartesian = 0,
  Inset = 1
}

enum LayoutPositioning : byte {
  Auto = 0,
  Absolute = 1
}

enum MainAxisAlignment : byte {
  None = 0,
  Start = 1,
  End = 2,
  Center = 3,
  SpaceBetween = 4,
  SpaceAround = 5,
  SpaceEvenly = 6,
  Stretch = 7
}

enum CrossAxisAlignment : byte {
  None = 0,
  Start = 1,
  End = 2,
  Center = 3,
  Stretch = 4
}

enum StrokeAlign : byte {
  Inside = 0,
  Center = 1,
  Outside = 2
}

enum StrokeCap : byte {
  Butt = 0,
  Round = 1,
  Square = 2
}

enum StrokeJoin : byte {
  Miter = 0,
  Round = 1,
  Bevel = 2
}

enum TextAlign : byte {
  Left = 0,
  Right = 1,
  Center = 2,
  Justify = 3
}

enum TextAlignVertical : byte {
  Top = 0,
  Center = 1,
  Bottom = 2
}

enum BooleanPathOperation : byte {
  Union = 0,
  Intersection = 1,
  Difference = 2,
  Xor = 3
}

enum BinaryEncoding : byte {
  Unknown = 0,
  JsonUtf8 = 1,
  Cbor = 2,
  NestedFlatbuffer = 3
}

enum SceneConstraintsChildren : byte {
  Single = 0,
  Multiple = 1
}

/// Rust: `FillRule`
enum FillRule : byte {
  NonZero = 0,
  EvenOdd = 1
}

/// Rust: `ImageMaskType`
enum ImageMaskType : byte {
  Alpha = 0,
  Luminance = 1
}

/// Rust: `LayerMaskType::Image(ImageMaskType)`
table LayerMaskTypeImage {
  image_mask_type:ImageMaskType = Alpha (id: 0);
}

/// Rust: `LayerMaskType::Geometry`
table LayerMaskTypeGeometry {}

/// Rust: `LayerMaskType`
union LayerMaskType {
  LayerMaskTypeImage = 1,
  LayerMaskTypeGeometry = 2
}

// -----------------------------------------------------------------------------
// Text style (Rust `cg::types::TextStyleRec` aligned)
// -----------------------------------------------------------------------------

/// Rust: `TextTransform`
enum TextTransform : byte {
  None = 0,
  Uppercase = 1,
  Lowercase = 2,
  Capitalize = 3
}

/// Rust: `TextDecorationLine`
enum TextDecorationLine : byte {
  None = 0,
  Underline = 1,
  Overline = 2,
  LineThrough = 3
}

/// Rust: `TextDecorationStyle`
enum TextDecorationStyle : byte {
  Solid = 0,
  Double = 1,
  Dotted = 2,
  Dashed = 3,
  Wavy = 4
}

/// Rust: `FontWeight(pub u32)`
struct FontWeight {
  value:uint;
}

/// Rust: `FontOpticalSizing` (Auto | None | Fixed(f32))
enum FontOpticalSizingKind : byte {
  Auto = 0,
  None = 1,
  Fixed = 2
}

struct FontOpticalSizing {
  kind:FontOpticalSizingKind;
  fixed_value:float;
}

/// Rust: `TextLineHeight` (Normal | Fixed(f32) | Factor(f32))
enum TextLineHeightKind : byte {
  Normal = 0,
  Fixed = 1,
  Factor = 2
}

struct TextLineHeight {
  kind:TextLineHeightKind;
  fixed_value:float;
  factor_value:float;
}

/// Rust: `TextLetterSpacing` (Fixed(f32) | Factor(f32))
enum TextLetterSpacingKind : byte {
  Fixed = 0,
  Factor = 1
}

// TODO: review this
struct TextLetterSpacing {
  kind:TextLetterSpacingKind;
  fixed_value:float;
  factor_value:float;
}

/// Rust: `TextWordSpacing` (Fixed(f32) | Factor(f32))
enum TextWordSpacingKind : byte {
  Fixed = 0,
  Factor = 1
}

struct TextWordSpacing {
  kind:TextWordSpacingKind;
  fixed_value:float;
  factor_value:float;
}

/// OpenType feature tag (4-byte ASCII, standard OpenType format).
///
/// OpenType feature tags are exactly 4 characters, stored as 4 bytes.
/// This matches the binary OpenType format where tags are stored as [u8; 4].
///
/// Examples:
///   "kern" = {a:0x6B, b:0x65, c:0x72, d:0x6E}
///   "liga" = {a:0x6C, b:0x69, c:0x67, d:0x61}
///   "ss01" = {a:0x73, b:0x73, c:0x30, d:0x31}
///
/// Codecs should convert between string tags (e.g., "kern") and this struct.
/// This approach allows any 4-character OpenType tag without schema evolution.
struct OpenTypeFeatureTag {
  a:ubyte;
  b:ubyte;
  c:ubyte;
  d:ubyte;
}

/// Rust: `FontFeature { tag: String, value: bool }`
table FontFeature {
  /// OpenType feature tag (4-byte encoding).
  /// Codecs should convert between string ("kern") and OpenTypeFeatureTag struct.
  open_type_feature_tag:OpenTypeFeatureTag (id: 0);
  open_type_feature_value:bool (id: 1);
}

/// Rust: `FontVariation { axis: String, value: f32 }`
table FontVariation {
  variation_axis:string (required, id: 0);
  variation_value:float (id: 1);
}

/// Rust: `TextDecorationRec`
///
/// Archive model notes:
/// - `decoration_color` uses RGBA32F (float space) to match this schema's color choice.
/// - When `decoration_color.a == 0`, runtimes may treat it as "unset" if desired.
table TextDecorationRec {
  text_decoration_line:TextDecorationLine = None (id: 0);
  text_decoration_color:RGBA32F (id: 1);
  text_decoration_style:TextDecorationStyle = Solid (id: 2);
  text_decoration_skip_ink:bool = true (id: 3);
  text_decoration_thickness:float = 1.0 (id: 4);
}

/// Rust: `TextStyleRec`
table TextStyleRec {
  text_decoration:TextDecorationRec (id: 0);

  font_family:string (required, id: 1);
  font_size:float = 14.0 (id: 2);
  font_weight:FontWeight (required, id: 3);
  font_width:float = 0.0 (id: 4);
  font_style_italic:bool = false (id: 5);
  font_kerning:bool = true (id: 6);
  font_optical_sizing:FontOpticalSizing (id: 7);

  font_features:[FontFeature] (id: 8);
  font_variations:[FontVariation] (id: 9);

  letter_spacing:TextLetterSpacing (id: 10);
  word_spacing:TextWordSpacing (id: 11);
  line_height:TextLineHeight (id: 12);
  text_transform:TextTransform = None (id: 13);
}

// -----------------------------------------------------------------------------
// Paints (Rust `cg::types` aligned)
// -----------------------------------------------------------------------------

struct GradientStop {
  stop_offset:float;
  stop_color:RGBA32F;
}

table SolidPaint {
  active:bool = true (id: 0);
  color:RGBA32F (id: 1);
  blend_mode:BlendMode = Normal (id: 2);
}

table LinearGradientPaint {
  active:bool = true (id: 0);
  /// Rust: `xy1: Alignment`
  xy1:Alignment (id: 1);
  /// Rust: `xy2: Alignment`
  xy2:Alignment (id: 2);
  tile_mode:TileMode = Clamp (id: 3);
  /// Rust: `transform: AffineTransform`
  transform:CGTransform2D (id: 4);
  stops:[GradientStop] (id: 5);
  opacity:float = 1.0 (id: 6);
  blend_mode:BlendMode = Normal (id: 7);
}

table RadialGradientPaint {
  active:bool = true (id: 0);
  /// Rust: `transform: AffineTransform`
  transform:CGTransform2D (id: 1);
  stops:[GradientStop] (id: 2);
  opacity:float = 1.0 (id: 3);
  blend_mode:BlendMode = Normal (id: 4);
  tile_mode:TileMode = Clamp (id: 5);
}

table DiamondGradientPaint {
  active:bool = true (id: 0);
  transform:CGTransform2D (id: 1);
  stops:[GradientStop] (id: 2);
  opacity:float = 1.0 (id: 3);
  blend_mode:BlendMode = Normal (id: 4);
}

table SweepGradientPaint {
  active:bool = true (id: 0);
  transform:CGTransform2D (id: 1);
  stops:[GradientStop] (id: 2);
  opacity:float = 1.0 (id: 3);
  blend_mode:BlendMode = Normal (id: 4);
}

/// Rust: `ResourceRef::HASH(String)`
table ResourceRefHASH {
  hash:string (id: 0);
}

/// Rust: `ResourceRef::RID(String)`
table ResourceRefRID {
  rid:string (id: 0);
}

/// Rust: `ResourceRef`
union ResourceRef {
  ResourceRefHASH = 1,
  ResourceRefRID = 2
}

/// Rust: `ImageFilters`
struct ImageFilters {
  exposure:float;
  contrast:float;
  saturation:float;
  temperature:float;
  tint:float;
  highlights:float;
  shadows:float;
}

/// Rust: `ImageTile`
struct ImageTile {
  scale:float;
  repeat:ImageRepeat;
}

/// Rust: `ImagePaintFit::Fit(BoxFit)`
table ImagePaintFitFit {
  box_fit:BoxFit = Cover (id: 0);
}

/// Rust: `ImagePaintFit::Transform(AffineTransform)`
table ImagePaintFitTransform {
  transform:CGTransform2D (id: 0);
}

/// Rust: `ImagePaintFit::Tile(ImageTile)`
table ImagePaintFitTile {
  tile:ImageTile (id: 0);
}

/// Rust: `ImagePaintFit`
union ImagePaintFit {
  ImagePaintFitFit = 1,
  ImagePaintFitTransform = 2,
  ImagePaintFitTile = 3
}

/// Rust: `ImagePaint`
table ImagePaint {
  active:bool = true (id: 0);
  image:ResourceRef (id: 2);
  quarter_turns:ubyte = 0 (id: 3);
  /// NOTE: Rust field name is `alignement` (typo preserved for 1:1)
  alignement:Alignment (id: 4);
  fit:ImagePaintFit (id: 6);
  opacity:float = 1.0 (id: 7);
  blend_mode:BlendMode = Normal (id: 8);
  filters:ImageFilters (id: 9);
}

union Paint {
  SolidPaint = 1,
  LinearGradientPaint = 2,
  RadialGradientPaint = 3,
  SweepGradientPaint = 4,
  DiamondGradientPaint = 5,
  ImagePaint = 6
}

table PaintStackItem {
  paint:Paint (id: 1);
}


// -----------------------------------------------------------------------------
// Scene-related structures
// -----------------------------------------------------------------------------


// TODO: rename to UXGuide2D
table Guide2D {
  axis:Axis;
  guide_offset:float;
}

table EdgePointPosition2D {
  x:float (id: 0);
  y:float (id: 1);
}

table EdgePointNodeAnchor {
  target:NodeIdentifier (id: 0); // node ID
}

union EdgePoint {
  EdgePointPosition2D = 1,
  EdgePointNodeAnchor = 2
}

table Edge2D {
  id:string (id: 0);
  a:EdgePoint (id: 2);
  b:EdgePoint (id: 4);
}


// -----------------------------------------------------------------------------
// Vector Network (Rust `vectornetwork/vn.rs` aligned)
// -----------------------------------------------------------------------------

/// Rust: `(f32, f32)` vertex
///
/// Stored as CGPoint (same coordinate space as node local geometry).
/// Indexed by position in the `vertices` array.
struct VectorNetworkVertex {
  vertex_position:CGPoint;
}

/// Rust: `VectorNetworkSegment { a, b, ta, tb }`
///
/// `tangent_a` / `tangent_b` are relative tangent vectors used for cubic béziers.
/// When both tangents are zero, the segment is a straight line.
struct VectorNetworkSegment {
  segment_vertex_a:uint;
  segment_vertex_b:uint;
  tangent_a:CGPoint;
  tangent_b:CGPoint;
}

/// Rust: `VectorNetworkLoop(pub Vec<usize>)`
///
/// A closed contour defined by indices into `segments`.
table VectorNetworkLoop {
  loop_segment_indices:[uint] (id: 0);
}

/// Rust: `VectorNetworkRegion { loops, fill_rule, fills }`
///
/// Archive model uses `region_fill_paints` (empty = no fill) instead of Option wrappers.
table VectorNetworkRegion {
  region_loops:[VectorNetworkLoop] (id: 0);
  region_fill_rule:FillRule = NonZero (id: 1);
  region_fill_paints:[PaintStackItem] (id: 2);
}

/// Rust: `VectorNetwork { vertices, segments, regions }`
table VectorNetworkData {
  vertices:[CGPoint] (id: 0);
  segments:[VectorNetworkSegment] (id: 1);
  regions:[VectorNetworkRegion] (id: 2);
}

// -----------------------------------------------------------------------------
// Effects (Rust `cg::fe` + `node::schema::LayerEffects` aligned)
// -----------------------------------------------------------------------------

/// Rust: `FeGaussianBlur { radius: f32 }`
table FeGaussianBlur {
  radius:float;
}

/// Rust: `FeProgressiveBlur { start: Alignment, end: Alignment, radius, radius2 }`
table FeProgressiveBlur {
  start:Alignment;
  end:Alignment;
  radius:float;
  radius2:float;
}

/// Rust: `FeBlur` (enum)
enum FeBlurKind : byte {
  Gaussian = 0,
  Progressive = 1
}

/// Struct-tagged representation of Rust `FeBlur`.
table FeBlur {
  kind:FeBlurKind;
  gaussian:FeGaussianBlur;
  progressive:FeProgressiveBlur;
}

/// Rust: `FeLayerBlur { blur: FeBlur, active: bool }`
table FeLayerBlur {
  blur:FeBlur;
  active:bool;
}

/// Rust: `FeBackdropBlur { blur: FeBlur, active: bool }`
table FeBackdropBlur {
  blur:FeBlur;
  active:bool;
}

/// Rust: `FeShadow { dx, dy, blur, spread, color, active }`
table FeShadow {
  dx:float;
  dy:float;
  blur:float;
  spread:float;
  color:RGBA32F;
  active:bool;
}

/// Rust: `FilterShadowEffect` (enum)
enum FilterShadowEffectKind : byte {
  DropShadow = 0,
  InnerShadow = 1
}

/// Struct-tagged representation of Rust `FilterShadowEffect`.
table FilterShadowEffect {
  kind:FilterShadowEffectKind;
  shadow:FeShadow;
}

/// Rust: `NoiseEffectColors` (enum)
enum NoiseEffectColorsKind : byte {
  Mono = 0,
  Duo = 1,
  Multi = 2
}

/// Struct-tagged representation of Rust `NoiseEffectColors`.
table NoiseEffectColors {
  kind:NoiseEffectColorsKind;
  mono_color:RGBA32F;
  duo_color1:RGBA32F;
  duo_color2:RGBA32F;
  multi_opacity:float;
}

/// Rust: `FeNoiseEffect`
table FeNoiseEffect {
  noise_size:float;
  density:float;
  num_octaves:int;
  seed:float;
  coloring:NoiseEffectColors;
  active:bool;
  blend_mode:BlendMode;
}

/// Rust: `FeLiquidGlass`
table FeLiquidGlass {
  light_intensity:float;
  light_angle:float;
  refraction:float;
  depth:float;
  dispersion:float;
  blur_radius:float;
  active:bool;
}


/// Effects trait used by nodes (Rust: `LayerEffects`).
///
/// Note: must be a table because it contains vectors (FlatBuffers structs cannot contain vectors).
table LayerEffects {
  fe_blur:FeLayerBlur (id: 0);
  fe_backdrop_blur:FeBackdropBlur (id: 1);
  fe_glass:FeLiquidGlass (id: 2);
  fe_shadows:[FilterShadowEffect] (id: 3);
  fe_noises:[FeNoiseEffect] (id: 4);
}

// -----------------------------------------------------------------------------
// Stroke (draft)
// -----------------------------------------------------------------------------

table StrokeStyle {
  stroke_align:StrokeAlign = Inside (id: 0);
  stroke_cap:StrokeCap = Butt (id: 1);
  stroke_join:StrokeJoin = Miter (id: 2);
  stroke_miter_limit:float = 4.0 (id: 3);
  /// dash array in logical pixels. Empty or omitted means "no dash".
  stroke_dash_array:[float] (id: 4);
}

/// A single stop in a variable-width stroke profile.
///
/// - `u` is the normalized position along the stroke in [0, 1].
/// - `r` is the half-width ("radius") at this position in pixels.
table VariableWidthStop {
  u:float (id: 0);
  r:float (id: 1);
}

/// Variable-width stroke profile.
///
/// Notes:
/// - This matches TS `cg.VariableWidthProfile` and Rust `cg::varwidth::{WidthStop, VarWidthProfile}` at the wire level.
/// - `base` is intentionally not stored here; renderers should derive a base half-width from the node's `stroke_width`
///   when `stops` is empty (see Rust `VarWidthSampler` behavior).
table VariableWidthProfile {
  stops:[VariableWidthStop] (id: 0);
}



// -----------------------------------------------------------------------------
// Node traits (composable building blocks)
// -----------------------------------------------------------------------------
//
// Motivation:
// - Keep node model "trait-based" (similar to TS trait composition), so each concern
//   has a dedicated schema type.
// - Makes future TS↔FBS mapping predictable: each TS trait maps to a single table.
//
// Notes:
// - FlatBuffers has no inheritance; traits are expressed via table composition.
// - Traits are tables (not structs) so we can use defaults + optional presence.
//
// -----------------------------------------------------------------------------

table StrokeGeometryTrait {
  stroke_width:float;
  stroke_style:StrokeStyle;
  stroke_width_profile:VariableWidthProfile;
}

table RectangularStrokeGeometryTrait {
  rectangular_stroke_width:RectangularStrokeWidth;
  stroke_style:StrokeStyle;
  stroke_width_profile:VariableWidthProfile;
}

table CorerRadiusTrait {
  corner_radius:CGRadius;
  corner_smoothing:float;
}

table RectangularCornerRadiusTrait {
  rectangular_corner_radius:RectangularCornerRadius;
  corner_smoothing:float;
}


// =============================================================================
// Primitive Shapes Geometry Descriptors
// =============================================================================


/// Rust: `EllipticalRingSectorShape` (arc/ring sector data for ellipses)
table CanonicalEllipticalShapeRingSectorParameters {
  /// Inner radius ratio (0..1)
  inner_radius_ratio:float = 0.0 (id: 0);
  /// Start angle in degrees
  start_angle:float = 0.0 (id: 1);
  /// Sweep angle in degrees (end_angle = start_angle + angle)
  angle:float = 360.0 (id: 2);
}

/// rectangle, rounded rectangle
table CanonicalShapeRectangular {
  // inherently has no property, as the size is defined by the layout. this is pure base shape description.
}

/// circle, ellipse by default and also can represent ring, sector, ring+sector
table CanonicalShapeElliptical {
  ring_sector_data:CanonicalEllipticalShapeRingSectorParameters;
}

/// polygon (any shapes defined by points)
table CanonicalShapePointsPolygon {
  // in 0-1 normalized coordinates (if its not normaized, it should be scaled to fit the box)
  points:[CGPoint];
  fill_rule:FillRule;
}

/// regular polygon
table CanonicalShapeRegularPolygon {
  point_count:uint;
}

/// regular star-ish polygon
table CanonicalShapeRegularStarPolygon {
  point_count:uint;
  inner_radius_ratio:float;
}

/// path
table CanonicalShapePath {
  // svg-compat path data in 0-1 normalized coordinates (if its not normaized, it should be scaled to fit the box)
  d:string;
  fill_rule:FillRule;
}

/// Canonical layer shape descriptor (geometry-only, layout-resolved).
///
/// `CanonicalLayerShape` is a *minimal*, *layout-independent* description of a
/// primitive shape used by layer-backed nodes (e.g. `BasicShapeNode`).
///
/// Core semantics:
/// - This union intentionally does NOT encode size (no width/height).
/// - The concrete geometry is produced by mapping the selected shape variant into
///   the node’s resolved layout box at render time.
/// - Shape-specific parameters are expressed in normalized or ratio form:
///     * points/polygon/path use 0..1 normalized coordinates (scaled to the box)
///     * ellipse ring/sector uses ratios + angles (interpreted in the box)
/// - All styling (fills, strokes, effects, corner traits, etc.) lives outside the
///   shape descriptor on the owning node/traits. This union is geometry-only.
///
/// Evolution rules:
/// - New primitive shape variants may be added by introducing a new `CanonicalShape*`
///   table and adding it to this union (additive change).
/// - Consumers must tolerate unknown union members (e.g. skip, treat as `UnknownNode`,
///   or fall back to a rectangle) rather than hard-failing, to preserve forward
///   compatibility.
///
/// Notes:
/// - The “Canonical” prefix indicates the representation is the stable, box-mapped
///   geometry form used in the archive, not a fully resolved mesh/path at a fixed size.
/// - Even when a variant currently has no fields (e.g. rectangular), it is kept as a
///   distinct member to preserve explicit author intent and allow future extensions
///   without changing other variants.
union CanonicalLayerShape {
  CanonicalShapeRectangular,
  CanonicalShapeElliptical,
  CanonicalShapePointsPolygon,
  CanonicalShapeRegularPolygon,
  CanonicalShapeRegularStarPolygon,
  CanonicalShapePath,
}



// -----------------------------------------------------------------------------
// Layout model (aligned to Rust `UniformNodeLayout`)
// -----------------------------------------------------------------------------

/// Explicit length value models (archive input model; CSS-ish).
///
/// NOTE: FlatBuffers unions can only include tables, not scalars/structs.
table Auto {}

table Px {
  value:float = 0.0 (id: 0);
}

table Percent {
  /// 0..100 domain (matching TS `css.Percentage.value`)
  value:float = 0.0 (id: 0);
}

/// Length input union.
///
/// Canonical mapping:
/// - TS `"auto"` -> `Auto`
/// - TS `number` or `{type:"length", unit:"px"}` -> `Px`
/// - TS `{type:"percentage"}` -> `Percent`
union Length {
  Auto = 1,
  Px = 2,
  Percent = 3
}

table LayoutDimensions {
  layout_target_width:Length (id: 1);
  layout_target_height:Length (id: 3);
  layout_min_width:float = 0.0 (id: 4);
  layout_max_width:float = 0.0 (id: 5);
  layout_min_height:float = 0.0 (id: 6);
  layout_max_height:float = 0.0 (id: 7);
  /// Preferred layout aspect ratio.
  ///
  /// Represents a proportional relationship between width and height expressed
  /// as a ratio pair (e.g. `[16, 9]`, `[4, 3]`, `[1, 1]`).
  ///
  /// Notes:
  /// - This does not define geometry by itself. It is a sizing preference that
  ///   layout engines may consult when resolving under-specified dimensions
  ///   (e.g. when either width or height is "auto") or when proportional sizing
  ///   is explicitly required by the layout model.
  /// - When both width and height are definitively specified, this should have
  ///   no effect and must not override explicit dimensions.
  /// - Layout engines may ignore this if aspect-ratio-aware sizing is not supported.
  ///
  /// Encoding:
  /// - Stored as a tuple (width, height) for parity with TS `layout_target_aspect_ratio?: [number, number]`.
  layout_target_aspect_ratio:CGSize (id: 8);
}

table LayoutContainerStyle {
  layout_mode:LayoutMode = Normal (id: 0);
  layout_direction:Axis = Horizontal (id: 1);
  layout_wrap:LayoutWrap = None (id: 2);
  layout_main_axis_alignment:MainAxisAlignment = None (id: 3);
  layout_cross_axis_alignment:CrossAxisAlignment = None (id: 4);
  layout_padding:EdgeInsets (id: 5);
  layout_main_axis_gap:float (id: 6);
  layout_cross_axis_gap:float (id: 7);
}

table LayoutChildStyle {
  layout_positioning:LayoutPositioning = Auto (id: 0);
  layout_grow:float (id: 1);
}

table Layout {
  layout_position_basis:LayoutPositionBasis = Cartesian (id: 0);
  layout_position:CGPoint (id: 1);
  layout_inset:EdgeInsets (id: 2);
  layout_dimensions:LayoutDimensions (id: 3);
  layout_container:LayoutContainerStyle (id: 4);
  layout_child:LayoutChildStyle (id: 5);
  /// Rotation in degrees.
  rotation:float = 0.0 (id: 6);
}

// -----------------------------------------------------------------------------
// Node payloads (draft; matches Rust Node variants at a coarse level)
// -----------------------------------------------------------------------------


table TextSpanNodeProperties {
  stroke_geometry:StrokeGeometryTrait;
  fill_paints:[PaintStackItem];
  stroke_paints:[PaintStackItem];
  text:string;
  text_style:TextStyleRec;
  text_align:TextAlign;
  text_align_vertical:TextAlignVertical;
  max_lines:uint;
  ellipsis:string;
}

// -----------------------------------------------------------------------------
// Nodes & hierarchy
// -----------------------------------------------------------------------------


/// Universal node trait.
table SystemNodeTrait {
  /// unique identifier for the node. (required)
  id:NodeIdentifier (required);
  /// name of the node. (optional)
  name:string;
  /// whether the node is active. (visible, active)
  active:bool;
  /// whether the node is locked. (locked, editor)
  locked:bool;
}


/// Shared layer fields used by all layer-node variants.
/// Layer is what usually user think of as a node. each layer is non-virtual, a real render target.
table LayerTrait {
  opacity:float = 1.0;
  /// Blend mode (archive model).
  ///
  /// Default is `pass_through`.
  blend_mode:LayerBlendMode = PassThrough;
  /// Rust: `LayerMaskType` (union; default is Image(alpha) since it's the first union member)
  mask_type:LayerMaskType;

  effects:LayerEffects;

  /// Parent reference (optional; root nodes omit this).
  ///
  /// When present, this node is a child of the referenced parent.
  /// Children are ordered by `position` (lexicographic sort).
  ///
  /// Reference: Aligned with Figma's `ParentIndex` pattern (fig.kiwi).
  /// This replaces the previous `children:[NodeIdentifier]` array model.
  ///
  /// To compute children of a parent node:
  /// 1. Filter all nodes where `parent.parent_id == parent.id`
  /// 2. Sort by `parent.position` (lexicographic comparison)
  parent:ParentReference (required);

  /// Geometry transform baseline (identity by default).
  relative_transform_snapshot:CGTransform2D;

  /// Layout (optional, depending on node type / usage).
  layout:Layout;
}


/// Placeholder, unused.
table UnknownNode {
  node:SystemNodeTrait (required);
}

/// Node variant: Scene.
///
/// SceneNode is special and doesn't use NodeCommon like other nodes.
/// It inlines only the relevant fields from NodeCommon.
table SceneNode {
  node:SystemNodeTrait (required);

  /// Scene-specific properties.
  constraints_children:SceneConstraintsChildren;
  /// Scene background color (solid color only, RGBA32F).
  ///
  /// This is a simple solid color background. For gradient or image backgrounds,
  /// use a background container node instead.
  scene_background_color:RGBA32F;
  guides:[Guide2D];
  edges:[Edge2D];
  /// Fractional index position string for ordering among siblings.
  /// Empty string means "unsorted" or "default position".
  /// Children are sorted by lexicographic comparison of position strings.
  position:string;
}

/// Node variant: Initial container.
table InitialContainerNode {
  node:SystemNodeTrait (required);
  layer:LayerTrait (required);
}

/// Node variant: Container.
table ContainerNode {
  node:SystemNodeTrait (required);
  layer:LayerTrait (required);
  stroke_geometry:RectangularStrokeGeometryTrait;
  corner_radius:RectangularCornerRadiusTrait;
  fill_paints:[PaintStackItem];
  stroke_paints:[PaintStackItem];
  /// Content-only clip flag (children only).
  clips_content:bool;
}

// TODO: review the group model from scratch.
/// Node variant: Group.
table GroupNode {
  node: SystemNodeTrait (required);
  layer:LayerTrait (required);
}

// TODO: review the shape, should boolop have direct child ?
/// Node variant: Boolean operation.
table BooleanOperationNode {
  node: SystemNodeTrait (required);
  layer: LayerTrait (required);
  op:BooleanPathOperation = Union;
  corner_radius:CorerRadiusTrait;
  fill_paints:[PaintStackItem];
  stroke_geometry:StrokeGeometryTrait;
  stroke_paints:[PaintStackItem];
}

table BasicShapeNode {
  node:SystemNodeTrait (required);
  layer:LayerTrait (required);

  // TODO: remove this
  /// shape of the type, must align with the shape. this is kept to keep the node type semantics.
  type:BasicShapeNodeType;
  shape:CanonicalLayerShape;
  corner_radius:float;
  corner_smoothing:float;
  
  fill_paints:[PaintStackItem];
  
  stroke_style:StrokeStyle;
  stroke_width:float;
  stroke_width_profile:VariableWidthProfile;
  rectangular_corner_radius:RectangularCornerRadius;
  rectangular_stroke_width:RectangularStrokeWidth;

  stroke_paints:[PaintStackItem];
}

/// Node variant: Line.
table LineNode {
  node: SystemNodeTrait (required);
  layer:LayerTrait (required);
  stroke_geometry:StrokeGeometryTrait;
  stroke_paints:[PaintStackItem];
}

/// Node variant: Vector.
table VectorNode {
  node:SystemNodeTrait (required);
  layer:LayerTrait (required);
  stroke_geometry:StrokeGeometryTrait;
  stroke_paints:[PaintStackItem];
  corner_radius:CorerRadiusTrait;
  fill_paints:[PaintStackItem];
  vector_network_data:VectorNetworkData;
}

/// Node variant: Text span.
table TextSpanNode {
  node:SystemNodeTrait (required);
  layer:LayerTrait (required);
  properties:TextSpanNodeProperties;
}


// -----------------------------------------------------------------------------
// Node encoding model: union-per-variant (why this, not an "all-flat" Node table)
// -----------------------------------------------------------------------------
//
// We model nodes as a FlatBuffers `union Node { SceneNode, ContainerNode, ... }`
// instead of a single mega-table like:
//
//   table Node {
//     type: NodeType;
//     ...hundreds of optional fields for every possible node kind...
//   }
//
// Rationale (why union is better here):
//
// 1) Prevents "optional-field explosion"
//    - A universal design document accumulates many fields that only apply to a
//      small subset of node kinds (e.g. vector networks, text properties, boolean ops).
//    - In an all-flat table, every new node feature adds more optional fields and
//      conditional decoding paths across *all* runtimes.
//    - With a union, each variant table contains only the fields relevant to that
//      node kind, keeping the schema and codecs smaller and easier to evolve.
//
// 2) Stronger invariants, fewer impossible states
//    - All-flat encodings tend to allow invalid combinations (a node kind with a
//      mismatched set of payload fields).
//    - With a union, the schema itself encodes a large portion of correctness:
//      the presence of `VectorNetworkData` implies `VectorNode`, `op` implies
//      `BooleanOperationNode`, etc.
//    - This reduces corruption risk and lowers validation surface area.
//
// 3) Cleaner evolution story for new node kinds
//    - Adding a new node kind becomes additive:
//        - define `NewNodeVariant` table
//        - add it to the `union Node`
//    - Existing variants remain unchanged (no need to touch a giant central Node table).
//    - This reduces migration churn and makes "forward evolution" easier to reason about.
//
// 4) Better runtime ergonomics (Rust/TS)
//    - Engines naturally branch by node kind:
//        - Rust: `match node { Node::TextSpan(t) => ..., Node::Vector(v) => ... }`
//        - TS: switch on discriminated variant
//    - Compared to "type + optional fields", union decoding avoids repetitive
//      `if type == ... then read ... else ignore` patterns.
//
// 5) Variant granularity is an intentional modeling choice
//    - The union does not imply "one variant per API class". Variants are chosen
//      to reflect *distinct semantic payload shapes* that matter for correctness,
//      editing behavior, and long-term evolution.
//    - Some families that are distinct at the API level may still share a single
//      storage representation when their payload structure is fundamentally the same.
//
// 6) Shared geometry family: `BasicShapeNode` is a deliberate bundling
//    - At the API level there may be separate concepts (e.g. Rectangle, Ellipse, Polygon),
//      but they share a large, coherent set of fields and behaviors in the archive model
//      (fills/strokes, corner parameters, minimal-shape descriptor, etc.).
//    - Encoding them as one variant reduces schema surface area and keeps codecs simpler,
//      while still preserving the specific shape identity via `shape: CanonicalLayerShape`
//      (and temporarily via `type: BasicShapeNodeType` during transition).
//    - Net effect: fewer variants where it doesn’t buy us stronger invariants, and fewer
//      chances for drift between near-identical tables across versions.
//
// Notes / constraints:
// - FlatBuffers unions can only contain tables, which aligns well with variant payloads.
// - Forward compatibility relies on consumers being able to treat unknown union members
//   as `UnknownNode` (or skip) rather than hard-failing.
// - Shared concerns (identity, hierarchy, transform, layout, effects) are intentionally
//   factored into reusable traits (`SystemNodeTrait`, `LayerTrait`) so variant tables
//   stay small and consistent.
//
// This design intentionally favors:
// - correctness by construction
// - smaller, more maintainable codecs
// - additive evolution as node kinds/features grow
//
// at the cost of:
// - one level of indirection per node (variant table)
// - care needed for unknown-variant handling across versions
union Node {
  UnknownNode,
  SceneNode,
  // groups and containers, hierarchial modifiers
  GroupNode,
  InitialContainerNode,
  ContainerNode,
  BooleanOperationNode,
  // primitive shapes
  BasicShapeNode,
  LineNode,
  VectorNode,
  // texts
  TextSpanNode,
}

// -----------------------------------------------------------------------------
// Document root
// -----------------------------------------------------------------------------

table CanvasDocument {
  /// Schema version string (keep in sync with TS `grida.program.document.SCHEMA_VERSION`).
  schema_version:string (id: 0);

  /// Flat node repository.
  nodes:[Node] (id: 2);

  /// Scene node ids (scene nodes are also stored in `nodes`).
  scenes:[NodeIdentifier] (id: 3);
}

/// Top-level wrapper (allows future multi-document bundles, signatures, etc.)
table GridaFile {
  document:CanvasDocument (id: 0);
}

root_type GridaFile;